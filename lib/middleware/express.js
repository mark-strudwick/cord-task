import bodyParser from 'body-parser';

import rules from './rules'
import { apiErrors } from './errors'

export default function (app) {
  app.set('port', process.env.PORT || 3000);
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded({ extended: true }));
}

 const validateRequest = (requestRoute, requestMethod, requestQueryParams, requestBodyKeys) => {
  if (!requestRoute || !requestMethod || !requestRoute[requestMethod]) {
    throw apiErrors.INVALID_ROUTE;
  };

  if ((requestQueryParams.length !== 0 || requestBodyKeys.length !== 0) && !requestRoute[requestMethod]['parameters']) {
    throw apiErrors.INVALID_REQUEST;
  };
}

const checkRequiredBodyParams = (requestRoute, requestMethod, requestBodyKeys) => {
  if (requestRoute[requestMethod]['parameters']) {
    requestRoute[requestMethod]['parameters'].forEach(param => {
      if (param['in'] === 'body' && param['schema'] && param['schema']['required']) {
        param['schema']['required'].forEach(requiredParam => {
          if (!requestBodyKeys.includes(requiredParam)) {
            throw apiErrors.JSON_MISSING_REQUIRED_FIELDS
          }
        })
      }
    }
    )
  }
}

const fetchAllowedParams = (requestRoute, requestMethod) => {
  const rulesBodyParams = [];
  const rulesQueryParams = {};

  if (!requestRoute[requestMethod].parameters) {
    return { rulesBodyParams, rulesQueryParams };
  }

  requestRoute[requestMethod].parameters.forEach(param => {
    if (param['in'] === 'body') {
      rulesBodyParams.push(param.schema.properties);
    };
    
    if (param['in'] == 'query') {
      rulesQueryParams[param.name] = param.type;
    };
  });

  return { rulesBodyParams, rulesQueryParams };
}

const validateRequestBody = (requestBodyKeys, rulesBodyParams, requestBody) => {
  requestBodyKeys.forEach(bodyKey => {
    if(!rulesBodyParams[bodyKey]) {
      throw apiErrors.INVALID_REQUEST;
    }

    switch (rulesBodyParams[bodyKey].type) {
      case 'string':
        if (typeof requestBody[bodyKey] !== 'string') {
          throw apiErrors.JSON_INVALID_TYPE;
        }
        break;
      case 'integer':
        // If body param is a string int ('1') this will fail
        if (!Number.isInteger(requestBody[bodyKey])) {
          throw apiErrors.JSON_INVALID_TYPE;
        }
        break;
      default:
        throw apiErrors.SERVER_ERROR;
    }
  })
};

const validateQueryStrings = (requestQueryParams, rulesQueryParams, requestQuery) => {
  requestQueryParams.forEach(param => {
    if (!rulesQueryParams[param]) {
      throw apiErrors.INVALID_REQUEST;
    }

    switch (rulesQueryParams[param]) {
      case 'string':
        if (typeof requestQuery[param] !== 'string') {
          throw apiErrors.INVALID_REQUEST;
        }
        break;
      case 'integer':
        requestQuery[param] = parseInt(requestQuery[param]);
        if (!Number.isInteger(requestQuery[param])) {
          throw apiErrors.INVALID_REQUEST;
        }
        break;
      case 'array':
        if (!Array.isArray(requestQuery[param])) {
          throw apiErrors.INVALID_REQUEST;
        };

        requestQuery[param].forEach(query => {
          if (typeof query !== 'string') {
            throw apiErrors.INVALID_REQUEST;
          }
        });
        break;
      default:
        throw apiErrors.SERVER_ERROR;
    }
  });
}

/**
 * TBD: middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw a 400 code error with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */
export const checkAgainstRules = (req, res, next) => {
  try {
    const requestRoute = rules.paths[req.baseUrl + req.path];
    const requestMethod = req.method.toLowerCase();
    const requestQueryParams = Object.keys(req.query);
    const requestBodyKeys = Object.keys(req.body);
    const requestBody = req.body;
    const requestQuery = req.query;


    validateRequest(requestRoute, requestMethod, requestQueryParams, requestBodyKeys);

    checkRequiredBodyParams(requestRoute, requestMethod, requestBodyKeys);

    let { rulesBodyParams, rulesQueryParams } = fetchAllowedParams(requestRoute, requestMethod);

    if (requestBodyKeys.length !== 0) {
      rulesBodyParams = Object.assign({}, ...rulesBodyParams)
      validateRequestBody(requestBodyKeys, rulesBodyParams, requestBody);
    };

    if (requestQueryParams.length !== 0) {
      validateQueryStrings(requestQueryParams, rulesQueryParams, requestQuery);
    };
  } catch (error) {
    res.status(error.code).send(error.message)
  }

  return next();
}
